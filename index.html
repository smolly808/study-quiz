<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>家庭学習クイズ</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; margin: 16px; line-height: 1.5; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 12px 0; }
    label { display:block; margin: 8px 0 4px; font-weight: 600; }
    select, input[type="number"], textarea, button {
      width: 100%; font-size: 16px; padding: 10px; border-radius: 10px; border: 1px solid #ccc;
    }
    textarea { resize: vertical; }
    button { cursor: pointer; border: none; background: #111; color: #fff; font-weight: 700; margin-top: 12px; }
    button.secondary { background: #eee; color: #111; border: 1px solid #ddd; }
    button:disabled { opacity: .55; cursor: not-allowed; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .muted { color: #666; font-size: 13px; margin-top: 6px; }
    .pill { display:inline-block; padding: 4px 10px; border-radius: 999px; background:#f3f3f3; margin-right: 6px; font-size: 12px; }
    .hr { height:1px; background:#eee; margin: 12px 0; }
    .qtitle { font-size: 18px; font-weight: 800; margin: 0 0 8px; }
    .choice { border: 1px solid #ddd; border-radius: 10px; padding: 10px; margin: 8px 0; cursor: pointer; }
    .choice:hover { background: #fafafa; }
    .choice.correct { border-color: #0a0; }
    .choice.wrong { border-color: #c00; }
    .big { font-size: 20px; font-weight: 900; }
    .center { text-align:center; }
    .hide { display:none !important; }
    .statline { display:flex; gap:8px; flex-wrap: wrap; align-items: center; }
    .glow { box-shadow: 0 0 0 3px rgba(255, 200, 0, .6); }
  </style>
</head>
<body>

<div class="card">
  <div class="big">家庭学習クイズ</div>
  <div class="muted">苦手ほど出題頻度が上がります（端末内保存）。</div>
</div>

<!-- 設定 -->
<div class="card" id="setup">
  <label>科目</label>
  <select id="subject">
    <option value="history">歴史</option>
    <option value="geography">地理</option>
    <option value="science">理科</option>
    <option value="art">美術</option>
    <option value="music">音楽</option>
    <option value="pe">保健体育</option>
    <option value="tech">技術</option>
  </select>

  <div class="row">
    <div>
      <label>大単元</label>
      <select id="unitBig"></select>
    </div>
    <div>
      <label>節</label>
      <select id="unitSection"></select>
    </div>
  </div>

  <label>出題範囲</label>
  <select id="rangeMode">
    <option value="section" selected>この節のみ</option>
    <option value="big">大単元全体（節をまたぐ）</option>
  </select>

  <div class="row">
    <div>
      <label>問題数</label>
      <input id="numQ" type="number" min="1" max="50" value="10" />
    </div>
    <div>
      <label>タイプ</label>
      <select id="typeFilter">
        <option value="">すべて</option>
        <option value="mcq">4択</option>
        <option value="keyword">キーワード</option>
        <option value="self">自己採点</option>
      </select>
    </div>
  </div>

  <label>出題モード</label>
  <select id="sessionMode">
    <option value="normal" selected>通常</option>
    <option value="wrongOnly">間違えた問題だけ</option>
  </select>

  <label>出題順</label>
  <select id="orderMode">
    <option value="random" selected>ランダム（苦手優先など適用）</option>
    <option value="sequential">全問順番（範囲を網羅）</option>
  </select>

  <label>苦手優先</label>
  <select id="weakMode">
    <option value="off">OFF（完全ランダム）</option>
    <option value="mid" selected>ON（標準）</option>
    <option value="strong">ON（強め）</option>
  </select>

  <label>演出</label>
  <select id="fxMode">
    <option value="on" selected>ON（効果音/光る/バイブ/連続正解）</option>
    <option value="off">OFF</option>
  </select>

  <button id="startBtn">出題開始</button>
  <button class="secondary" id="reloadBtn">単元一覧を再読込</button>

  <div class="hr"></div>
  <div class="muted" id="statsSummary"></div>
</div>

<!-- クイズ -->
<div class="card hide" id="quiz">
  <div class="statline">
    <span class="pill" id="pillRange">範囲:</span>
    <span class="pill" id="pillMode">モード:</span>
    <span class="pill" id="pillOrder">順:</span>
    <span class="pill" id="pillType">タイプ:</span>
    <span class="pill" id="pillProgress">0/0</span>
    <span class="pill" id="pillScore">正解:0</span>
    <span class="pill" id="pillStreak">連続:0</span>
  </div>

  <div class="hr"></div>

  <div class="qtitle" id="qTitle"></div>
  <div class="muted" id="qMeta"></div>

  <div id="choicesArea"></div>

  <div class="hr"></div>

  <div id="keywordArea" class="hide">
    <label>答え（キーワード）</label>
    <input id="keywordInput" placeholder="入力して送信" />
    <button id="keywordSubmit">判定</button>
  </div>

  <div id="selfArea" class="hide">
    <div class="muted">自己採点：答えを見たら「正解／不正解」を選んでください。</div>
    <button id="selfOk">正解</button>
    <button class="secondary" id="selfNg">不正解</button>
  </div>

  <div id="explainArea" class="hide">
    <div class="hr"></div>
    <div class="big">解説</div>
    <div id="explainText"></div>
    <button id="nextBtn">次へ</button>
  </div>
</div>

<!-- 結果 -->
<div class="card hide" id="result">
  <div class="big center">結果</div>
  <div class="center" id="resultSummary"></div>
  <div class="hr"></div>
  <div id="resultDetail"></div>
  <button id="backBtn">戻る</button>
</div>

<script>
  // ★あなたのexec URLに置き換え（デプロイし直してURLが変わったらここも更新）
  const API_BASE = "https://script.google.com/macros/s/AKfycby_XupzA1UK5gauggJylLRDfK7NaCJPaul24MkHcceFa9ywBWNu8wLf3vHy3S0T57IHJg/exec";

  // =========================
  // 状態
  // =========================
  let allForSubject = [];   // その科目の全問題
  let quizList = [];        // 今回出題する問題配列
  let idx = 0;
  let correct = 0;
  let results = [];
  let streak = 0;
  let bestStreak = 0;

  const els = {
    setup: document.getElementById('setup'),
    quiz: document.getElementById('quiz'),
    result: document.getElementById('result'),

    subject: document.getElementById('subject'),
    unitBig: document.getElementById('unitBig'),
    unitSection: document.getElementById('unitSection'),
    rangeMode: document.getElementById('rangeMode'),
    numQ: document.getElementById('numQ'),
    typeFilter: document.getElementById('typeFilter'),
    sessionMode: document.getElementById('sessionMode'),
    orderMode: document.getElementById('orderMode'),
    weakMode: document.getElementById('weakMode'),
    fxMode: document.getElementById('fxMode'),

    startBtn: document.getElementById('startBtn'),
    reloadBtn: document.getElementById('reloadBtn'),

    statsSummary: document.getElementById('statsSummary'),

    pillRange: document.getElementById('pillRange'),
    pillMode: document.getElementById('pillMode'),
    pillOrder: document.getElementById('pillOrder'),
    pillType: document.getElementById('pillType'),
    pillProgress: document.getElementById('pillProgress'),
    pillScore: document.getElementById('pillScore'),
    pillStreak: document.getElementById('pillStreak'),

    qTitle: document.getElementById('qTitle'),
    qMeta: document.getElementById('qMeta'),
    choicesArea: document.getElementById('choicesArea'),

    keywordArea: document.getElementById('keywordArea'),
    keywordInput: document.getElementById('keywordInput'),
    keywordSubmit: document.getElementById('keywordSubmit'),

    selfArea: document.getElementById('selfArea'),
    selfOk: document.getElementById('selfOk'),
    selfNg: document.getElementById('selfNg'),

    explainArea: document.getElementById('explainArea'),
    explainText: document.getElementById('explainText'),
    nextBtn: document.getElementById('nextBtn'),

    resultSummary: document.getElementById('resultSummary'),
    resultDetail: document.getElementById('resultDetail'),
    backBtn: document.getElementById('backBtn'),
  };

  // =========================
  // ユーティリティ
  // =========================
  function show(el, yes) { el.classList.toggle('hide', !yes); }

  function buildUrl(params) {
    const u = new URL(API_BASE);
    Object.entries(params || {}).forEach(([k,v]) => u.searchParams.set(k, v));
    // キャッシュ回避
    u.searchParams.set("_ts", Date.now().toString());
    return u.toString();
  }

  function fetchJSONP(url) {
    return new Promise((resolve, reject) => {
      const cbName = "jsonp_cb_" + Math.random().toString(36).slice(2);
      const u = new URL(url);
      u.searchParams.set("callback", cbName);

      const s = document.createElement("script");
      window[cbName] = (payload) => {
        try { resolve(payload); }
        finally {
          delete window[cbName];
          s.remove();
        }
      };
      s.onerror = () => {
        reject(new Error("JSONP load failed"));
        delete window[cbName];
        s.remove();
      };
      s.src = u.toString();
      document.body.appendChild(s);
    });
  }

  function normalizeQuestion(q) {
    // 既存の運用に合わせて軽く正規化
    const qq = Object.assign({}, q);
    qq.id = String(qq.id ?? "").trim();
    qq.subject = String(qq.subject ?? "").toLowerCase().trim();
    qq.unit_big = String(qq.unit_big ?? "").trim();
    qq.unit_section = String(qq.unit_section ?? "").trim();
    qq.type = String(qq.type ?? "").toLowerCase().trim();

    qq.group_id = String(qq.group_id ?? "").trim();
    qq.group_order = (qq.group_order === "" || qq.group_order === null || typeof qq.group_order === "undefined") ? "" : Number(qq.group_order);
    qq.question_order = (qq.question_order === "" || qq.question_order === null || typeof qq.question_order === "undefined") ? "" : Number(qq.question_order);

    qq.unit_big_order = (qq.unit_big_order === "" || qq.unit_big_order === null || typeof qq.unit_big_order === "undefined") ? "" : Number(qq.unit_big_order);
    qq.unit_section_order = (qq.unit_section_order === "" || qq.unit_section_order === null || typeof qq.unit_section_order === "undefined") ? "" : Number(qq.unit_section_order);

    return qq;
  }

  // =========================
  // 苦手データ（端末内）
  // =========================
  const STATS_KEY = "quiz_stats_v1";

  function loadStats() {
    try {
      return JSON.parse(localStorage.getItem(STATS_KEY) || "{}");
    } catch {
      return {};
    }
  }

  function saveStats(stats) {
    localStorage.setItem(STATS_KEY, JSON.stringify(stats));
  }

  function isWrongQuestion(q) {
    const stats = loadStats();
    const id = String(q.id ?? "");
    const s = stats[id];
    return s && Number(s.ng || 0) > 0;
  }

  function recordAnswer(q, ok) {
    const stats = loadStats();
    const id = String(q.id ?? "");
    const s = stats[id] || { ok: 0, ng: 0, lastAt: 0 };
    if (ok) s.ok = Number(s.ok || 0) + 1;
    else s.ng = Number(s.ng || 0) + 1;
    s.lastAt = Date.now();
    stats[id] = s;
    saveStats(stats);
  }

  function weightForQuestion(q, mode) {
    if (mode === "off") return 1;

    const stats = loadStats();
    const id = String(q.id ?? "");
    const s = stats[id] || { ok: 0, ng: 0, lastAt: 0 };

    const ok = Number(s.ok || 0);
    const ng = Number(s.ng || 0);
    const total = ok + ng;

    // 間違い率
    const wrongRate = total === 0 ? 0.2 : (ng / total);

    // しばらく出ていない問題ほど少し優遇（最大 1.5倍）
    const days = (Date.now() - Number(s.lastAt || 0)) / (1000 * 60 * 60 * 24);
    const recencyBoost = Math.min(1.5, 1 + Math.max(0, days / 14));

    let base = 1 + wrongRate * 4; // 1〜5程度
    if (mode === "strong") base *= 1.4;
    if (mode === "mid") base *= 1.1;

    return base * recencyBoost;
  }

  // =========================
  // グループ（連続出題）関連
  // =========================
  function buildGroupBlocks(pool) {
    const groups = new Map();  // gid -> [q...]
    const singles = [];

    for (const q of pool) {
      const gid = String(q.group_id || "").trim();
      if (!gid) {
        singles.push(q);
        continue;
      }
      if (!groups.has(gid)) groups.set(gid, []);
      groups.get(gid).push(q);
    }

    // グループ内は group_order 昇順（未入力は最後）
    for (const [gid, arr] of groups.entries()) {
      arr.sort((a,b) => {
        const ao = Number.isFinite(Number(a.group_order)) ? Number(a.group_order) : 999999;
        const bo = Number.isFinite(Number(b.group_order)) ? Number(b.group_order) : 999999;
        return ao - bo || String(a.id||"").localeCompare(String(b.id||""), 'ja');
      });
    }

    return { groups, singles };
  }

  function weightForBlock(block, weakMode) {
    // block: {type:"single", q} or {type:"group", gid, arr}
    if (block.type === "single") return weightForQuestion(block.q, weakMode);

    // group: 最大重み（グループ内に苦手が1問でもあれば出やすい）
    let w = 0.2;
    for (const q of block.arr) w = Math.max(w, weightForQuestion(q, weakMode));
    return w;
  }

  function sampleBlocksUnique(blocks, maxQuestions, weakMode) {
    // maxQuestions は「目標」。グループは切らず、超えても全部追加する方針。
    const items = blocks.map(b => ({ b, w: weightForBlock(b, weakMode) }));
    const picked = [];
    let count = 0;

    while (items.length > 0 && count < maxQuestions) {
      const sum = items.reduce((a,x) => a + x.w, 0);
      let r = Math.random() * sum;

      let idxPick = 0;
      for (; idxPick < items.length; idxPick++) {
        r -= items[idxPick].w;
        if (r <= 0) break;
      }
      if (idxPick >= items.length) idxPick = items.length - 1;

      const chosen = items[idxPick].b;
      const addN = (chosen.type === "single") ? 1 : chosen.arr.length;

      picked.push(chosen);
      count += addN;

      items.splice(idxPick, 1);
    }
    return picked;
  }

  function flattenBlocksToQuizList(blocksPicked) {
    const list = [];
    for (const b of blocksPicked) {
      if (b.type === "single") list.push(b.q);
      else list.push(...b.arr);
    }
    return list;
  }

  // 全問順番モード用：範囲を網羅して順番に出す
  function sortSequential(pool) {
    return [...pool].sort((a,b) => {
      const aBigO = Number.isFinite(Number(a.unit_big_order)) ? Number(a.unit_big_order) : 999999;
      const bBigO = Number.isFinite(Number(b.unit_big_order)) ? Number(b.unit_big_order) : 999999;

      const aSecO = Number.isFinite(Number(a.unit_section_order)) ? Number(a.unit_section_order) : 999999;
      const bSecO = Number.isFinite(Number(b.unit_section_order)) ? Number(b.unit_section_order) : 999999;

      const aQO = Number.isFinite(Number(a.question_order)) ? Number(a.question_order) : 999999;
      const bQO = Number.isFinite(Number(b.question_order)) ? Number(b.question_order) : 999999;

      const aG = String(a.group_id || "").trim();
      const bG = String(b.group_id || "").trim();
      const aGO = Number.isFinite(Number(a.group_order)) ? Number(a.group_order) : 999999;
      const bGO = Number.isFinite(Number(b.group_order)) ? Number(b.group_order) : 999999;

      return (
        aBigO - bBigO ||
        String(a.unit_big||"").localeCompare(String(b.unit_big||""),'ja') ||
        aSecO - bSecO ||
        String(a.unit_section||"").localeCompare(String(b.unit_section||""),'ja') ||
        // 同じグループなら group_order を優先
        ((aG && bG && aG === bG) ? (aGO - bGO) : 0) ||
        aQO - bQO ||
        String(a.id||"").localeCompare(String(b.id||""), 'ja')
      );
    });
  }

  // =========================
  // 単元一覧の生成
  // =========================
  function buildUnitsForSubject(subject) {
    const list = allForSubject.filter(q => q.subject === subject);

    // 大単元候補（順序があるなら order で並べる）
    const bigMap = new Map(); // unit_big -> order
    for (const q of list) {
      const key = q.unit_big || "";
      if (!key) continue;
      const o = Number.isFinite(Number(q.unit_big_order)) ? Number(q.unit_big_order) : 999999;
      if (!bigMap.has(key)) bigMap.set(key, o);
      else bigMap.set(key, Math.min(bigMap.get(key), o));
    }

    const bigs = Array.from(bigMap.entries())
      .sort((a,b) => (a[1]-b[1]) || a[0].localeCompare(b[0],'ja'))
      .map(([k]) => k);

    // 節候補は big を選んだ後に作る
    return { bigs };
  }

  function buildSections(subject, unitBig) {
    const list = allForSubject.filter(q => q.subject === subject && String(q.unit_big||"") === String(unitBig||""));
    const secMap = new Map(); // unit_section -> order
    for (const q of list) {
      const key = q.unit_section || "";
      if (!key) continue;
      const o = Number.isFinite(Number(q.unit_section_order)) ? Number(q.unit_section_order) : 999999;
      if (!secMap.has(key)) secMap.set(key, o);
      else secMap.set(key, Math.min(secMap.get(key), o));
    }
    return Array.from(secMap.entries())
      .sort((a,b) => (a[1]-b[1]) || a[0].localeCompare(b[0],'ja'))
      .map(([k]) => k);
  }

  function setSelectOptions(selectEl, items) {
    selectEl.innerHTML = "";
    for (const it of items) {
      const opt = document.createElement("option");
      opt.value = it;
      opt.textContent = it;
      selectEl.appendChild(opt);
    }
  }

  // =========================
  // 範囲抽出
  // =========================
  function currentPool() {
    const subject = els.subject.value;
    const unitBig = els.unitBig.value;
    const unitSection = els.unitSection.value;
    const type = els.typeFilter.value;
    const rangeMode = els.rangeMode.value;

    let pool = allForSubject.filter(q =>
      String(q.subject||"").toLowerCase() === subject &&
      String(q.unit_big||"").trim() === unitBig
    );
    if (rangeMode === "section") {
      pool = pool.filter(q => String(q.unit_section||"").trim() === unitSection);
    }
    if (type) pool = pool.filter(q => String(q.type||"").toLowerCase() === type);
    return pool;
  }

  // =========================
  // 統計サマリ（表示用）
  // =========================
  function summarizeStatsForPool(pool) {
    const stats = loadStats();
    let ok = 0, ng = 0, tried = 0;
    for (const q of pool) {
      const s = stats[String(q.id ?? "")];
      if (!s) continue;
      const o = Number(s.ok || 0);
      const n = Number(s.ng || 0);
      ok += o; ng += n;
      if (o + n > 0) tried++;
    }
    return { ok, ng, tried, total: pool.length };
  }

  function refreshStatsSummary() {
    const pool = currentPool();
    if (pool.length === 0) { els.statsSummary.textContent = ""; return; }

    const sum = summarizeStatsForPool(pool);
    const rangeLabel = (els.rangeMode.value === "big") ? "大単元全体" : "この節のみ";
    const wrongOnly = (els.sessionMode.value === "wrongOnly") ? "（間違えた問題だけ）" : "";
    const orderLabel = (els.orderMode.value === "sequential") ? "全問順番" : "ランダム";
    els.statsSummary.textContent =
      `範囲：${rangeLabel}${wrongOnly}／順：${orderLabel}／問題数：${sum.total}（解いたことがある：${sum.tried}）／正解:${sum.ok} 不正解:${sum.ng}`;
  }

  // =========================
  // クイズ開始（ここが今回の核心）
  // =========================
  function startQuiz() {
    let pool = currentPool();
    const n = Math.max(1, Math.min(50, Number(els.numQ.value || 10)));
    const weakMode = els.weakMode.value;
    const sessionMode = els.sessionMode.value;
    const orderMode = els.orderMode.value;

    if (pool.length === 0) {
      alert("この条件の問題がありません。問題を追加するか、条件を変えてください。");
      return;
    }

    // 間違えた問題だけ
    if (sessionMode === "wrongOnly") {
      const wrongPool = pool.filter(isWrongQuestion);
      if (wrongPool.length === 0) {
        alert("この範囲では「間違えた問題」がまだありません。まず通常モードで解いて履歴を作ってください。");
        return;
      }
      pool = wrongPool;
    }

    if (orderMode === "sequential") {
      // 全問順番（範囲を網羅）
      quizList = sortSequential(pool);

      // もし「問題数」を上限にしたい場合は↓を有効化
      // quizList = quizList.slice(0, n);

    } else {
      // ランダム（グループは必ず連続）
      const { groups, singles } = buildGroupBlocks(pool);

      const blocks = [];
      for (const q of singles) blocks.push({ type: "single", q });
      for (const [gid, arr] of groups.entries()) blocks.push({ type: "group", gid, arr });

      const pickedBlocks = sampleBlocksUnique(blocks, n, weakMode);
      quizList = flattenBlocksToQuizList(pickedBlocks);
    }

    idx = 0;
    correct = 0;
    results = [];
    streak = 0;
    bestStreak = 0;

    updatePills();

    show(els.setup, false);
    show(els.result, false);
    show(els.quiz, true);

    renderQuestion(quizList[0]);
  }

  function updatePills() {
    const rangeLabel = (els.rangeMode.value === "big") ? "大単元" : "節";
    const modeLabel = (els.sessionMode.value === "wrongOnly") ? "間違い" : "通常";
    const orderLabel = (els.orderMode.value === "sequential") ? "順番" : "ランダム";
    const typeLabel = els.typeFilter.value ? els.typeFilter.value : "全部";

    els.pillRange.textContent = "範囲:" + rangeLabel;
    els.pillMode.textContent = "モード:" + modeLabel;
    els.pillOrder.textContent = "順:" + orderLabel;
    els.pillType.textContent = "タイプ:" + typeLabel;

    els.pillProgress.textContent = `${Math.min(idx+1, quizList.length)}/${quizList.length}`;
    els.pillScore.textContent = `正解:${correct}`;
    els.pillStreak.textContent = `連続:${streak}`;
  }

  // =========================
  // 出題表示
  // =========================
  function renderQuestion(q) {
    if (!q) return;

    updatePills();

    els.qTitle.textContent = String(q.question || "").trim();
    const meta = [];
    if (q.unit_big) meta.push(`大単元：${q.unit_big}`);
    if (q.unit_section) meta.push(`節：${q.unit_section}`);
    if (q.group_id) meta.push(`グループ：${q.group_id}（順:${q.group_order || "?"}）`);
    els.qMeta.textContent = meta.join(" ／ ");

    els.choicesArea.innerHTML = "";
    els.explainArea.classList.add("hide");
    els.keywordArea.classList.add("hide");
    els.selfArea.classList.add("hide");

    const type = String(q.type || "").toLowerCase();

    if (type === "mcq") {
      const choices = parseChoices(q);
      for (const ch of choices) {
        const div = document.createElement("div");
        div.className = "choice";
        div.textContent = ch;
        div.addEventListener("click", () => answerMCQ(q, ch, div));
        els.choicesArea.appendChild(div);
      }
    } else if (type === "keyword") {
      els.keywordArea.classList.remove("hide");
      els.keywordInput.value = "";
      els.keywordInput.focus();
    } else {
      // self / その他
      els.selfArea.classList.remove("hide");
    }
  }

  function parseChoices(q) {
    // choices が "A|B|C|D" や改行区切りなど色々あり得る想定
    const raw = String(q.choices || "").trim();
    if (!raw) return [];
    if (raw.includes("|")) return raw.split("|").map(s => s.trim()).filter(Boolean);
    return raw.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
  }

  function normalizeAnswerText(s) {
    return String(s || "").trim().toLowerCase();
  }

  function answerMCQ(q, chosen, chosenEl) {
    // 連打防止：一度選んだら全部 disable 的にする
    const children = Array.from(els.choicesArea.children);
    for (const c of children) c.style.pointerEvents = "none";

    const ans = normalizeAnswerText(q.answer);
    const ok = normalizeAnswerText(chosen) === ans;

    if (ok) {
      chosenEl.classList.add("correct");
      correct++;
      streak++;
      bestStreak = Math.max(bestStreak, streak);
      recordAnswer(q, true);
      fxCorrect();
    } else {
      chosenEl.classList.add("wrong");
      streak = 0;
      recordAnswer(q, false);
      fxWrong();
      // 正解も表示でマーキング
      for (const c of children) {
        if (normalizeAnswerText(c.textContent) === ans) c.classList.add("correct");
      }
    }

    results.push({ id: q.id, ok, q });

    showExplain(q, ok);
  }

  function showExplain(q, ok) {
    els.explainArea.classList.remove("hide");
    const exp = [];
    if (q.answer) exp.push(`<div><b>答え：</b>${escapeHtml(String(q.answer))}</div>`);
    if (q.explanation) exp.push(`<div style="margin-top:8px;">${escapeHtml(String(q.explanation))}</div>`);
    els.explainText.innerHTML = exp.join("");

    els.nextBtn.textContent = (idx >= quizList.length - 1) ? "結果へ" : "次へ";
  }

  function escapeHtml(s) {
    return String(s)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  // keyword
  function judgeKeyword() {
    const q = quizList[idx];
    const input = normalizeAnswerText(els.keywordInput.value);
    const ans = normalizeAnswerText(q.answer);

    const ok = input && ans && input === ans;
    if (ok) {
      correct++;
      streak++;
      bestStreak = Math.max(bestStreak, streak);
      recordAnswer(q, true);
      fxCorrect();
    } else {
      streak = 0;
      recordAnswer(q, false);
      fxWrong();
    }

    results.push({ id: q.id, ok, q });
    showExplain(q, ok);
  }

  // self
  function judgeSelf(ok) {
    const q = quizList[idx];
    if (ok) {
      correct++;
      streak++;
      bestStreak = Math.max(bestStreak, streak);
      recordAnswer(q, true);
      fxCorrect();
    } else {
      streak = 0;
      recordAnswer(q, false);
      fxWrong();
    }
    results.push({ id: q.id, ok, q });
    showExplain(q, ok);
  }

  // 次へ
  function next() {
    if (idx >= quizList.length - 1) {
      finish();
      return;
    }
    idx++;
    renderQuestion(quizList[idx]);
  }

  function finish() {
    show(els.quiz, false);
    show(els.result, true);

    const total = quizList.length;
    els.resultSummary.innerHTML = `
      <div style="margin-top:10px;">${total}問中 <span class="big">${correct}</span>問 正解</div>
      <div class="muted">連続正解ベスト：${bestStreak}</div>
    `;

    const lines = [];
    for (const r of results) {
      const title = escapeHtml(String(r.q.question || ""));
      const mark = r.ok ? "✅" : "❌";
      const gid = r.q.group_id ? `（${escapeHtml(r.q.group_id)}-${escapeHtml(String(r.q.group_order||""))}）` : "";
      lines.push(`<div style="margin:10px 0;">${mark} ${title} <span class="muted">${gid}</span></div>`);
    }
    els.resultDetail.innerHTML = lines.join("");

    refreshStatsSummary();
  }

  // =========================
  // 演出
  // =========================
  function fxEnabled() {
    return els.fxMode.value === "on";
  }

  function fxCorrect() {
    if (!fxEnabled()) return;
    els.quiz.classList.add("glow");
    try { navigator.vibrate && navigator.vibrate([40]); } catch {}
    setTimeout(() => els.quiz.classList.remove("glow"), 150);
  }

  function fxWrong() {
    if (!fxEnabled()) return;
    try { navigator.vibrate && navigator.vibrate([60, 40, 60]); } catch {}
  }

  // =========================
  // データ読み込み
  // =========================
  async function loadSubjectData() {
    const subject = els.subject.value;
    const url = buildUrl({ subject });
    const payload = await fetchJSONP(url);

    if (!payload || !payload.data) {
      console.log(payload);
      throw new Error("データ取得に失敗しました（payload不正）");
    }

    allForSubject = payload.data.map(normalizeQuestion);

    // 大単元→節のセレクトを更新
    const units = buildUnitsForSubject(subject);
    setSelectOptions(els.unitBig, units.bigs);

    // bigが空なら何もしない
    if (!els.unitBig.value && units.bigs.length > 0) els.unitBig.value = units.bigs[0];

    const sections = buildSections(subject, els.unitBig.value);
    setSelectOptions(els.unitSection, sections);
    if (!els.unitSection.value && sections.length > 0) els.unitSection.value = sections[0];

    refreshStatsSummary();
  }

  // =========================
  // イベント
  // =========================
  els.startBtn.addEventListener("click", startQuiz);
  els.reloadBtn.addEventListener("click", () => loadSubjectData().catch(err => alert(err.message)));

  els.subject.addEventListener("change", () => loadSubjectData().catch(err => alert(err.message)));
  els.unitBig.addEventListener("change", () => {
    const sections = buildSections(els.subject.value, els.unitBig.value);
    setSelectOptions(els.unitSection, sections);
    if (sections.length > 0) els.unitSection.value = sections[0];
    refreshStatsSummary();
  });

  els.unitSection.addEventListener("change", refreshStatsSummary);
  els.rangeMode.addEventListener("change", refreshStatsSummary);
  els.typeFilter.addEventListener("change", refreshStatsSummary);
  els.sessionMode.addEventListener("change", refreshStatsSummary);
  els.orderMode.addEventListener("change", refreshStatsSummary);
  els.weakMode.addEventListener("change", refreshStatsSummary);

  els.keywordSubmit.addEventListener("click", judgeKeyword);
  els.keywordInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") judgeKeyword();
  });

  els.selfOk.addEventListener("click", () => judgeSelf(true));
  els.selfNg.addEventListener("click", () => judgeSelf(false));

  els.nextBtn.addEventListener("click", next);
  els.backBtn.addEventListener("click", () => {
    show(els.result, false);
    show(els.setup, true);
  });

  // 初期ロード
  loadSubjectData().catch(err => alert(err.message));
</script>

</body>
</html>








