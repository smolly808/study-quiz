<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>家庭学習クイズ</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", sans-serif; margin: 16px; line-height: 1.5; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 12px 0; }
    label { display:block; margin: 8px 0 4px; font-weight: 600; }
    select, input[type="number"], textarea, button {
      width: 100%; font-size: 16px; padding: 10px; border-radius: 10px; border: 1px solid #ccc;
    }
    textarea { resize: vertical; }
    button { border: none; background: #111; color: #fff; margin-top: 10px; }
    button.secondary { background: #666; }
    button.danger { background:#b00020; }
    button:disabled { background:#ccc; color:#777; }
    .row { display:flex; gap:10px; }
    .row > * { flex:1; }
    .muted { color:#666; font-size: 13px; }
    .pill { display:inline-block; padding: 2px 8px; border:1px solid #ddd; border-radius: 999px; font-size: 12px; margin-right:6px; }
    .choices button { background:#f3f3f3; color:#111; border:1px solid #ddd; margin: 8px 0; text-align:left; }
    .ok { color:#0a7; font-weight:700; }
    .ng { color:#d33; font-weight:700; }
    hr { border:none; border-top:1px solid #eee; margin:12px 0; }
  </style>
</head>
<body>

<h2>家庭学習クイズ</h2>
<div class="muted">苦手ほど出題頻度が上がります（端末内保存）。</div>

<!-- 設定 -->
<div class="card" id="setup">
  <label>科目</label>
  <select id="subject">
    <option value="history">歴史</option>
    <option value="geography">地理</option>
    <option value="science">理科</option>
    <option value="art">美術</option>
    <option value="music">音楽</option>
    <option value="pe">保健体育</option>
    <option value="tech">技術</option>
  </select>

  <div class="row">
    <div>
      <label>大単元</label>
      <select id="unitBig"></select>
    </div>
    <div>
      <label>節</label>
      <select id="unitSection"></select>
    </div>
  </div>

  <div class="row">
    <div>
      <label>問題数</label>
      <input id="numQ" type="number" min="1" max="50" value="10" />
    </div>
    <div>
      <label>タイプ</label>
      <select id="typeFilter">
        <option value="">すべて</option>
        <option value="mcq">4択</option>
        <option value="keyword">キーワード</option>
        <option value="self">自己採点</option>
      </select>
    </div>
  </div>

  <label>苦手優先</label>
  <select id="weakMode">
    <option value="off">OFF（完全ランダム）</option>
    <option value="mid" selected>ON（標準）</option>
    <option value="strong">ON（強め）</option>
  </select>

  <button id="startBtn">出題開始</button>
  <button class="secondary" id="reloadBtn">単元一覧を再読込</button>

  <button class="danger" id="resetStatsBtn">学習履歴をリセット（この端末）</button>

  <div class="muted" id="status"></div>
  <div class="muted" id="statsSummary"></div>
</div>

<!-- 出題 -->
<div class="card" id="quiz" style="display:none;">
  <div id="progress" class="muted"></div>
  <div id="meta"></div>
  <h3 id="qText"></h3>

  <div id="mcqArea" class="choices" style="display:none;"></div>

  <div id="kwArea" style="display:none;">
    <label>回答（文章でOK）</label>
    <textarea id="kwInput" rows="3" placeholder="ここに入力"></textarea>
    <button id="kwCheckBtn" disabled>採点する</button>
    <div class="muted">※入力が空のときは採点できません</div>
  </div>

  <div id="selfArea" style="display:none;">
    <label>回答（任意）</label>
    <textarea id="selfInput" rows="3" placeholder="ここに入力（任意）"></textarea>
    <button id="selfRevealBtn">模範解答・解説を見る</button>
    <div id="selfReveal" style="display:none; margin-top:10px;"></div>
    <div id="selfMark" style="display:none;">
      <button id="selfOkBtn">○（正解）</button>
      <button class="secondary" id="selfNgBtn">×（不正解）</button>
    </div>
  </div>

  <hr />
  <div id="feedback"></div>

  <button class="secondary" id="nextBtn" style="display:none;">次の問題</button>
  <button class="secondary" id="quitBtn">やめる（結果へ）</button>
</div>

<!-- 結果 -->
<div class="card" id="result" style="display:none;">
  <h3>結果</h3>
  <div id="scoreLine"></div>
  <div id="review"></div>
  <button id="backBtn">トップへ戻る</button>
</div>

<script>
  // ★あなたのexec URL
  const API_BASE = "https://script.google.com/macros/s/AKfycbyVNfQjqvEJZAKv13SOULHAqLUk2WZEFRdotZBL_aRPQDYXdklTcSojvDrMndnI3qdGsw/exec";

  // ====== 学習履歴（端末内） ======
  const STATS_KEY = "quiz_stats_v1"; // { [id]: {ok, ng, lastAt} }

  function loadStats() {
    try { return JSON.parse(localStorage.getItem(STATS_KEY) || "{}"); }
    catch { return {}; }
  }
  function saveStats(stats) {
    localStorage.setItem(STATS_KEY, JSON.stringify(stats));
  }
  function recordAttempt(q, ok) {
    const id = String(q.id ?? "");
    if (!id) return;
    const stats = loadStats();
    const cur = stats[id] || { ok: 0, ng: 0, lastAt: 0 };
    if (ok) cur.ok += 1; else cur.ng += 1;
    cur.lastAt = Date.now();
    stats[id] = cur;
    saveStats(stats);
  }
  function summarizeStatsForPool(pool) {
    const stats = loadStats();
    let seen = 0, ok = 0, ng = 0;
    for (const q of pool) {
      const id = String(q.id ?? "");
      const s = stats[id];
      if (!s) continue;
      seen += 1;
      ok += (s.ok || 0);
      ng += (s.ng || 0);
    }
    return { seen, ok, ng };
  }
  function resetStats() {
    localStorage.removeItem(STATS_KEY);
  }

  // 重み計算：苦手ほど重く、最近間違いに少しブースト
  function weightForQuestion(q, mode) {
    if (mode === "off") return 1;

    const stats = loadStats();
    const id = String(q.id ?? "");
    const s = stats[id] || { ok: 0, ng: 0, lastAt: 0 };

    const ok = Number(s.ok || 0);
    const ng = Number(s.ng || 0);
    const total = ok + ng;

    // 不正解率（未学習は0扱い＝普通）
    const wrongRate = total > 0 ? (ng / total) : 0;

    // 最近間違えたら少しブースト（24時間以内）
    const recentHours = (Date.now() - (s.lastAt || 0)) / 36e5;
    const recentBoost = (ng > 0 && recentHours <= 24) ? 0.4 : 0;

    // モードごとに強さを変える
    const k = (mode === "strong") ? 3.0 : 2.0;   // 不正解率の効き
    const b = (mode === "strong") ? 1.3 : 1.1;   // 不正解回数の効き

    // 未学習にも少し出したいので base=1 は維持
    const w = 1
      + k * wrongRate
      + b * Math.min(5, ng) / 5
      + recentBoost;

    return Math.max(0.2, w);
  }

  // 重み付き抽出（重複なし）
  function sampleWeightedUnique(pool, n, mode) {
    const items = pool.map(q => ({ q, w: weightForQuestion(q, mode) }));
    const picked = [];
    const N = Math.min(n, items.length);

    for (let i = 0; i < N; i++) {
      const sum = items.reduce((a, x) => a + x.w, 0);
      let r = Math.random() * sum;
      let idx = -1;
      for (let j = 0; j < items.length; j++) {
        r -= items[j].w;
        if (r <= 0) { idx = j; break; }
      }
      if (idx < 0) idx = items.length - 1;
      picked.push(items[idx].q);
      items.splice(idx, 1);
    }
    return picked;
  }

  // ====== UI ======
  const els = {
    subject: document.getElementById('subject'),
    unitBig: document.getElementById('unitBig'),
    unitSection: document.getElementById('unitSection'),
    numQ: document.getElementById('numQ'),
    typeFilter: document.getElementById('typeFilter'),
    weakMode: document.getElementById('weakMode'),
    startBtn: document.getElementById('startBtn'),
    reloadBtn: document.getElementById('reloadBtn'),
    resetStatsBtn: document.getElementById('resetStatsBtn'),
    status: document.getElementById('status'),
    statsSummary: document.getElementById('statsSummary'),

    setup: document.getElementById('setup'),
    quiz: document.getElementById('quiz'),
    result: document.getElementById('result'),

    progress: document.getElementById('progress'),
    meta: document.getElementById('meta'),
    qText: document.getElementById('qText'),

    mcqArea: document.getElementById('mcqArea'),

    kwArea: document.getElementById('kwArea'),
    kwInput: document.getElementById('kwInput'),
    kwCheckBtn: document.getElementById('kwCheckBtn'),

    selfArea: document.getElementById('selfArea'),
    selfInput: document.getElementById('selfInput'),
    selfRevealBtn: document.getElementById('selfRevealBtn'),
    selfReveal: document.getElementById('selfReveal'),
    selfMark: document.getElementById('selfMark'),
    selfOkBtn: document.getElementById('selfOkBtn'),
    selfNgBtn: document.getElementById('selfNgBtn'),

    feedback: document.getElementById('feedback'),
    nextBtn: document.getElementById('nextBtn'),
    quitBtn: document.getElementById('quitBtn'),

    scoreLine: document.getElementById('scoreLine'),
    review: document.getElementById('review'),
    backBtn: document.getElementById('backBtn'),
  };

  let allForSubject = [];
  let quizList = [];
  let idx = 0;
  let correct = 0;
  let results = [];
  let isAnswered = false;

  function show(el, on) { el.style.display = on ? "" : "none"; }

  function qs(params) {
    const u = new URL(API_BASE);
    Object.entries(params).forEach(([k,v]) => {
      if (v !== undefined && v !== null && String(v).trim() !== "") u.searchParams.set(k, v);
    });
    u.searchParams.set("_t", Date.now().toString());
    return u.toString();
  }

  function fetchJSONP(url) {
    return new Promise((resolve, reject) => {
      const cbName = "jsonp_cb_" + Math.random().toString(36).slice(2);
      const u = new URL(url);
      u.searchParams.set("callback", cbName);

      const script = document.createElement("script");
      script.src = u.toString();

      window[cbName] = (data) => { cleanup(); resolve(data); };
      script.onerror = () => { cleanup(); reject(new Error("JSONP load failed")); };

      function cleanup() { delete window[cbName]; script.remove(); }
      document.body.appendChild(script);
    });
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  function uniqSortUnits(items) {
    const map = new Map();
    for (const it of items) {
      const name = (it.unit_big ?? "").toString().trim();
      if (!name) continue;
      const order = Number(it.unit_big_order);
      if (!map.has(name)) map.set(name, {name, order: Number.isFinite(order) ? order : 9999});
    }
    return Array.from(map.values())
      .sort((a,b) => a.order - b.order || a.name.localeCompare(b.name,'ja'))
      .map(x => x.name);
  }

  function uniqSortSections(items, unitBig) {
    const map = new Map();
    for (const it of items) {
      const big = (it.unit_big ?? "").toString().trim();
      if (big !== unitBig) continue;
      const sec = (it.unit_section ?? "").toString().trim();
      if (!sec) continue;
      const order = Number(it.unit_section_order);
      if (!map.has(sec)) map.set(sec, {sec, order: Number.isFinite(order) ? order : 9999});
    }
    return Array.from(map.values())
      .sort((a,b) => a.order - b.order || a.sec.localeCompare(b.sec,'ja'))
      .map(x => x.sec);
  }

  async function loadCatalog() {
    els.status.textContent = "読み込み中…";
    const subject = els.subject.value;

    const json = await fetchJSONP(qs({ subject }));
    allForSubject = json.data || [];

    const unitBigs = uniqSortUnits(allForSubject);
    els.unitBig.innerHTML = unitBigs.length
      ? unitBigs.map(u => `<option value="${escapeHtml(u)}">${escapeHtml(u)}</option>`).join("")
      : `<option value="">（問題なし）</option>`;

    const firstBig = unitBigs[0] || "";
    const sections = uniqSortSections(allForSubject, firstBig);
    els.unitSection.innerHTML = sections.length
      ? sections.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join("")
      : `<option value="">（節なし）</option>`;

    els.status.textContent = `読み込み完了：${json.count}件（科目=${subject}）`;
    refreshStatsSummary();
  }

  function currentPool() {
    const subject = els.subject.value;
    const unitBig = els.unitBig.value;
    const unitSection = els.unitSection.value;
    const type = els.typeFilter.value;

    let pool = allForSubject.filter(q =>
      String(q.subject||"").toLowerCase() === subject &&
      String(q.unit_big||"").trim() === unitBig &&
      String(q.unit_section||"").trim() === unitSection
    );
    if (type) pool = pool.filter(q => String(q.type||"").toLowerCase() === type);
    return pool;
  }

  function refreshStatsSummary() {
    const pool = currentPool();
    const sum = summarizeStatsForPool(pool);
    if (pool.length === 0) {
      els.statsSummary.textContent = "";
      return;
    }
    els.statsSummary.textContent =
      `この条件の問題：${pool.length}問 / 学習済み：${sum.seen}問（正解${sum.ok}・不正解${sum.ng}）`;
  }

  function resetQuizUI() {
    isAnswered = false;

    els.feedback.innerHTML = "";
    show(els.nextBtn, false);
    show(els.mcqArea, false);
    show(els.kwArea, false);
    show(els.selfArea, false);

    els.kwInput.value = "";
    els.kwInput.disabled = false;
    els.kwCheckBtn.disabled = true;
    els.kwCheckBtn.textContent = "採点する";

    els.selfInput.value = "";
    els.selfInput.disabled = false;
    els.selfReveal.innerHTML = "";
    show(els.selfReveal, false);
    show(els.selfMark, false);
    els.selfRevealBtn.disabled = false;
    els.selfRevealBtn.textContent = "模範解答・解説を見る";
    els.selfOkBtn.disabled = false;
    els.selfNgBtn.disabled = false;
  }

  function lockAfterAnswered(type) {
    isAnswered = true;

    if (type === "keyword") {
      els.kwCheckBtn.disabled = true;
      els.kwInput.disabled = true;
      els.kwCheckBtn.textContent = "採点済み";
    }

    if (type === "self") {
      els.selfRevealBtn.disabled = true;
      els.selfOkBtn.disabled = true;
      els.selfNgBtn.disabled = true;
      els.selfInput.disabled = true;
      els.selfRevealBtn.textContent = "採点済み";
    }
  }

  function showAnswerBlock(q) {
    const ans = (q.answer ?? "").toString();
    const exp = (q.explanation ?? "").toString();
    let html = "";
    if (ans) html += `<div><strong>模範解答：</strong>${escapeHtml(ans)}</div>`;
    if (exp) html += `<div style="margin-top:6px;"><strong>解説：</strong>${escapeHtml(exp)}</div>`;
    return html || `<div class="muted">（模範解答/解説が未入力です）</div>`;
  }

  function renderQuestion(q) {
    resetQuizUI();

    els.progress.textContent = `問題 ${idx + 1} / ${quizList.length}`;
    els.meta.innerHTML =
      `<span class="pill">${escapeHtml(q.subject || "")}</span>` +
      `<span class="pill">${escapeHtml(q.unit_big || "")}</span>` +
      `<span class="pill">${escapeHtml(q.unit_section || "")}</span>` +
      (q.tags ? `<span class="pill">${escapeHtml(q.tags)}</span>` : "");

    els.qText.textContent = String(q.question || "");

    const type = String(q.type || "").toLowerCase();

    if (type === "mcq") {
      show(els.mcqArea, true);
      const choices = [
        ["A", q.choice_a],
        ["B", q.choice_b],
        ["C", q.choice_c],
        ["D", q.choice_d]
      ].filter(([,v]) => String(v||"").trim() !== "");

      els.mcqArea.innerHTML = choices.map(([k,v]) =>
        `<button data-k="${k}"><strong>${k}.</strong> ${escapeHtml(v)}</button>`
      ).join("");

      els.mcqArea.querySelectorAll("button").forEach(btn => {
        btn.addEventListener("click", () => {
          if (isAnswered) return;
          const picked = btn.getAttribute("data-k");
          gradeMCQ(q, picked);
        }, { once: true });
      });

    } else if (type === "keyword") {
      show(els.kwArea, true);

      els.kwInput.oninput = () => {
        if (isAnswered) return;
        els.kwCheckBtn.disabled = els.kwInput.value.trim().length === 0;
      };

      els.kwCheckBtn.onclick = () => {
        if (isAnswered) return;
        gradeKeyword(q);
      };

    } else {
      show(els.selfArea, true);

      els.selfRevealBtn.onclick = () => {
        if (isAnswered) return;
        revealSelf(q);
      };

      els.selfOkBtn.onclick = () => {
        if (isAnswered) return;
        markSelf(q, true);
      };

      els.selfNgBtn.onclick = () => {
        if (isAnswered) return;
        markSelf(q, false);
      };
    }
  }

  function afterGrade(q, ok, type) {
    results.push({ ok, q: q.question, unit_big: q.unit_big, unit_section: q.unit_section });
    if (ok) correct++;

    // ★ここで学習履歴に保存（苦手克服の核心）
    recordAttempt(q, ok);

    lockAfterAnswered(type);

    show(els.nextBtn, true);
    els.nextBtn.onclick = next;
  }

  function gradeMCQ(q, picked) {
    const correctKey = String(q.correct||"").trim().toUpperCase();
    const ok = picked === correctKey;

    els.feedback.innerHTML =
      `<div>${ok ? `<span class="ok">正解</span>` : `<span class="ng">不正解</span>`}（あなた：${picked} / 正解：${correctKey || "?"}）</div>` +
      `<div style="margin-top:8px;">${showAnswerBlock(q)}</div>`;

    afterGrade(q, ok, "mcq");
  }

  function gradeKeyword(q) {
    const input = els.kwInput.value || "";
    const kws = String(q.keywords||"").split(",").map(s => s.trim()).filter(Boolean);
    const need = Number(q.keyword_min || 1);
    const hit = kws.filter(k => input.includes(k)).length;
    const ok = hit >= (Number.isFinite(need) ? need : 1);

    els.feedback.innerHTML =
      `<div>${ok ? `<span class="ok">正解</span>` : `<span class="ng">不正解</span>`}（一致：${hit} / 必要：${need}）</div>` +
      (kws.length ? `<div class="muted">キーワード：${escapeHtml(kws.join(" / "))}</div>` : "") +
      `<div style="margin-top:8px;">${showAnswerBlock(q)}</div>`;

    afterGrade(q, ok, "keyword");
  }

  function revealSelf(q) {
    els.selfReveal.innerHTML = showAnswerBlock(q);
    show(els.selfReveal, true);
    show(els.selfMark, true);
  }

  function markSelf(q, ok) {
    els.feedback.innerHTML = `<div>自己採点：${ok ? `<span class="ok">○</span>` : `<span class="ng">×</span>`}</div>`;
    afterGrade(q, ok, "self");
  }

  function next() {
    idx++;
    if (idx >= quizList.length) return showResult();
    renderQuestion(quizList[idx]);
  }

  function showResult() {
    show(els.setup, false);
    show(els.quiz, false);
    show(els.result, true);

    els.scoreLine.innerHTML =
      `<div><strong>${correct} / ${quizList.length}</strong>（正答率 ${(correct/quizList.length*100).toFixed(0)}%）</div>`;

    const wrongs = results.filter(r => !r.ok);
    if (wrongs.length === 0) {
      els.review.innerHTML = `<div class="ok">全問正解！</div>`;
    } else {
      els.review.innerHTML =
        `<div class="ng">間違い：${wrongs.length}問</div>` +
        `<ol>${wrongs.map(w => `<li>${escapeHtml(w.unit_big||"")} / ${escapeHtml(w.unit_section||"")}：${escapeHtml(w.q||"")}</li>`).join("")}</ol>`;
    }

    // 結果画面に戻ったら、トップ表示時にサマリ更新されるように
  }

  function startQuiz() {
    const pool = currentPool();
    const n = Math.max(1, Math.min(50, Number(els.numQ.value || 10)));
    const mode = els.weakMode.value;

    if (pool.length === 0) {
      alert("この条件の問題がありません。問題を追加するか、条件を変えてください。");
      return;
    }

    // ★苦手優先の重み付き抽出
    quizList = sampleWeightedUnique(pool, n, mode);

    idx = 0;
    correct = 0;
    results = [];

    show(els.setup, false);
    show(els.result, false);
    show(els.quiz, true);

    renderQuestion(quizList[0]);
  }

  // イベント
  els.reloadBtn.onclick = () => loadCatalog().catch(e => els.status.textContent = "読込失敗：" + e.message);
  els.subject.onchange = () => loadCatalog().catch(e => els.status.textContent = "読込失敗：" + e.message);

  els.unitBig.onchange = () => {
    const big = els.unitBig.value;
    const sections = uniqSortSections(allForSubject, big);
    els.unitSection.innerHTML = sections.length
      ? sections.map(s => `<option value="${escapeHtml(s)}">${escapeHtml(s)}</option>`).join("")
      : `<option value="">（節なし）</option>`;
    refreshStatsSummary();
  };

  els.unitSection.onchange = refreshStatsSummary;
  els.typeFilter.onchange = refreshStatsSummary;

  els.weakMode.onchange = refreshStatsSummary;

  els.startBtn.onclick = startQuiz;

  els.quitBtn.onclick = showResult;
  els.backBtn.onclick = () => {
    show(els.result,false);
    show(els.quiz,false);
    show(els.setup,true);
    refreshStatsSummary();
  };

  els.resetStatsBtn.onclick = () => {
    if (!confirm("この端末の学習履歴をすべてリセットします。よろしいですか？")) return;
    resetStats();
    refreshStatsSummary();
    alert("リセットしました。");
  };

  // 初期読込
  loadCatalog().catch(e => els.status.textContent = "初期読込失敗：" + e.message);
</script>

</body>
</html>
